# SVN 代码审核工具 - GUI 改造说明

## 改造概述

本次改造将原有的纯 CLI 工具升级为支持 Web GUI 和 CLI 双模式的应用，在不改变任何业务逻辑的前提下，提供了更友好的图形界面。

## 改造内容

### 1. 新增文件

#### `gui/server.go`
- Web 服务器实现
- HTTP API 接口
- 业务逻辑调用（复用原有代码）

#### `gui/templates/index.html`
- 现代化的 Web 界面
- 响应式设计
- 实时日志显示
- 文件选择功能

#### `GUI使用说明.md`
- 详细的使用文档
- 常见问题解答

### 2. 修改文件

#### `main.go`
**改动说明**：
- 添加启动模式判断逻辑
- 无参数时启动 Web GUI
- 有参数时使用 CLI 模式

**改动前**：
```go
func main() {
	if err := cmd.Execute(); err != nil {
		fmt.Fprintf(os.Stderr, "错误: %v\n", err)
		os.Exit(1)
	}
}
```

**改动后**：
```go
func main() {
	// 如果有命令行参数，使用 CLI 模式
	if len(os.Args) > 1 {
		if err := cmd.Execute(); err != nil {
			fmt.Fprintf(os.Stderr, "错误: %v\n", err)
			os.Exit(1)
		}
		return
	}

	// 否则启动 Web GUI 模式
	server := gui.NewServer()
	if err := server.Start(); err != nil {
		fmt.Fprintf(os.Stderr, "启动服务器失败: %v\n", err)
		os.Exit(1)
	}
}
```

#### `build.bat`
**改动说明**：
- 移除 `-ldflags="-H windowsgui"` 参数（不再需要隐藏控制台）
- 更新使用说明

#### `README.md`
**改动说明**：
- 添加 Web GUI 使用说明
- 更新功能特性列表
- 更新项目结构说明

### 3. 依赖变化

**移除的依赖**：
- `fyne.io/fyne/v2` - 原计划使用但因需要 C 编译器而放弃

**新增的依赖**：
- 无（使用 Go 标准库实现）

## 技术方案

### 为什么选择 Web GUI？

1. **无需额外依赖**：纯 Go 实现，不需要 CGO 或 C 编译器
2. **跨平台兼容**：在 Windows/Linux/Mac 上都能正常运行
3. **易于部署**：单个可执行文件，内嵌所有资源
4. **现代化界面**：使用 HTML5/CSS3/JavaScript 实现美观的界面
5. **易于维护**：前后端分离，代码结构清晰

### 架构设计

```
┌─────────────────────────────────────────┐
│           main.go (入口)                 │
│  ┌─────────────┐      ┌──────────────┐  │
│  │  CLI 模式   │      │  GUI 模式    │  │
│  │  (cmd/)     │      │  (gui/)      │  │
│  └─────────────┘      └──────────────┘  │
└─────────────────────────────────────────┘
              │                │
              └────────┬───────┘
                       ↓
        ┌──────────────────────────┐
        │   业务逻辑层 (internal/)  │
        │  ┌────────┐  ┌─────────┐ │
        │  │   AI   │  │   SVN   │ │
        │  └────────┘  └─────────┘ │
        │  ┌────────┐  ┌─────────┐ │
        │  │ Config │  │ Report  │ │
        │  └────────┘  └─────────┘ │
        └──────────────────────────┘
```

### API 设计

#### POST /api/load-config
加载配置文件
```json
Request: { "config_path": "config.yaml" }
Response: { "success": true, "config": {...} }
```

#### POST /api/scan
扫描 SVN 变更
```json
Request: { "work_dir": "." }
Response: { "success": true, "files": [...] }
```

#### POST /api/review
执行代码审核
```json
Request: { "work_dir": ".", "indices": [0,1,2] }
Response: { "success": true, "report_path": "..." }
```

## 业务逻辑保持不变

### 完全复用的模块

1. **internal/ai/** - AI 客户端逻辑
2. **internal/svn/** - SVN 操作逻辑
3. **internal/config/** - 配置管理
4. **internal/report/** - 报告生成
5. **cmd/** - CLI 命令实现

### 代码复用示例

GUI 模式中的审核逻辑与 CLI 模式完全一致：

```go
// CLI 模式 (cmd/review.go)
svnClient := svn.NewClient(cfg.SVN.Command, workDir)
changes, err := svnClient.GetChangedFiles(cfg.Ignore)
aiClient, err := ai.NewClient(&cfg.AI)
result, err := aiClient.Review(ctx, change.Path, diff, cfg.ReviewPrompt)

// GUI 模式 (gui/server.go)
svnClient := svn.NewClient(s.cfg.SVN.Command, req.WorkDir)
changes, err := svnClient.GetChangedFiles(s.cfg.Ignore)
aiClient, err := ai.NewClient(&s.cfg.AI)
result, err := aiClient.Review(ctx, change.Path, diff, s.cfg.ReviewPrompt)
```

## 使用方式对比

### GUI 模式（新增）
```bash
# 直接运行，启动 Web 界面
svn-reviewer.exe

# 或双击可执行文件
```

### CLI 模式（保持不变）
```bash
# 所有原有命令都正常工作
svn-reviewer.exe review
svn-reviewer.exe review -d /path/to/repo
svn-reviewer.exe review -i
svn-reviewer.exe review --help
```

## 优势总结

1. ✅ **向后兼容**：所有 CLI 功能完全保留
2. ✅ **零依赖**：不需要安装额外的库或工具
3. ✅ **易于使用**：图形界面降低使用门槛
4. ✅ **代码复用**：业务逻辑 100% 复用
5. ✅ **易于部署**：单文件部署，开箱即用
6. ✅ **跨平台**：Windows/Linux/Mac 通用
7. ✅ **现代化**：美观的界面设计
8. ✅ **实时反馈**：日志实时显示

## 构建和测试

### 构建
```bash
# Windows
build.bat

# 或手动构建
go mod tidy
go build -o svn-reviewer.exe
```

### 测试
```bash
# 测试 GUI 模式
svn-reviewer.exe

# 测试 CLI 模式
svn-reviewer.exe review --help
```

## 后续优化建议

1. **端口配置**：支持自定义端口
2. **主题切换**：支持深色/浅色主题
3. **历史记录**：保存审核历史
4. **批量操作**：支持批量审核多个仓库
5. **WebSocket**：使用 WebSocket 实现更流畅的实时更新
6. **进度条**：显示详细的审核进度
7. **报告预览**：在界面中直接预览报告

## 总结

本次改造成功地将 CLI 工具升级为双模式应用，在保持所有原有功能的同时，提供了更友好的用户体验。通过使用 Web 技术栈，避免了原生 GUI 框架的复杂依赖问题，实现了真正的跨平台、零依赖部署。
